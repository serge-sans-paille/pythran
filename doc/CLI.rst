This file shows some use case of Pythran on the command line.

Firstly lets clear the working space::
  $> rm -f cli_*

..  Small hack to setup the $PATH in a compatible way
..  >>> import os, pythran, re
..  >>> if 'lib' in pythran.__file__: os.environ['PATH'] = re.sub(r'(.*)/lib/.*', r'\1/bin:', pythran.__file__) + os.environ['PATH']
..  >>> os.environ['PATH'] = './scripts:' + os.environ['PATH']

One of the most classic use case in Pythran is to generate a native .so module::
  $> printf '#pythran export foo()\ndef foo(): print \"hello world\"' > cli_foo.py
  $> pythran cli_foo.py
  $> ls cli_foo.so
  cli_foo.so

The generated native .so module can then be called with the python interpreter::
  $> python -c 'import cli_foo ; cli_foo.foo()'
  hello world

You can choose your optimization level by using ``-O`` flag::
  $> rm cli_foo.so
  $> pythran cli_foo.py -O2
  $> ls cli_foo.so
  cli_foo.so

You can use ``-p`` option to apply a Pythran optimization. For example, the python
code translated by Pythran can be generated by using python backend::
  $> pythran -e cli_foo.py -p pythran.backend.Python
  import itertools
  def foo():
      print 'hello world'
      return __builtin__.None
  def __init__():
      return __builtin__.None
  __init__()

If you want to specify the path of generated file::
  $> pythran cli_foo.py -o /tmp/cli_foo.so
  $> ls /tmp/cli_foo.so
  /tmp/cli_foo.so

To know more options about Pythran, you can check ``pythran --help``::
Before you leave, clear the demo if you don't need them::
  $> rm -f cli_*
