/* pythonic/python/export.hpp */

#ifndef PYTHONIC_PYTHON_EXPORT_HPP
#define PYTHONIC_PYTHON_EXPORT_HPP

/**
  Macros to help define global types.

  Since the functions are templated and the globals are declared outside the functions,
  we need to specify beforehand the signatures of the functions we're going to call,
  in case they affect the globals. (before including the c++ header generated by pythran)

  Two scenarii:
  - only one signature, use pythran_export_solo(module, function, arg1, arg2, ...)
  - multiple signatues, start with pythran_export_start, then pythran_export_multi for each
    and finish with pythran_export_end

  Note that those are only necessary when there are globals in the code, and oftentimes you only need
  to specify it for a few of the high-level functions you're calling, and the code deduces the signatures
  of the other functions from those specifications.

  When compiling from python to a .so module directly, pythran deduces the signatures from the exports
  provided in the python code.
*/

#define pythran_export_start(module, funcname, ...) \
    namespace __pythran_##module{\
    template <int N> \
    struct funcname##_globals {\
    };\
    \
    template<>\
    struct funcname##_globals<__COUNTER__> {\
        template<typename combiner, typename or_type>\
        using global_type = or_type;\
    }; \
    \
    pythran_export_multi(module, funcname, ##__VA_ARGS__)

#define pythran_export_multi(module, funcname, ...) pythran_export_multi_I(__COUNTER__, module, funcname, ##__VA_ARGS__)
#define pythran_export_multi_I(N, module, funcname, ...) \
    template<> \
    struct funcname##_globals<N> { \
        template<typename combiner, typename or_type> \
        using global_type = funcname##_globals<N-1>::template global_type<combiner, typename combiner::template type<or_type, ##__VA_ARGS__>::instanciation>; \
    };

#define pythran_export_end(module, funcname, ...) pythran_export_end_I(__COUNTER__, module, funcname, ##__VA_ARGS__)
#define pythran_export_end_I(N, module, funcname, ...) \
    pythran_export_multi_I(N, module, funcname, ##__VA_ARGS__) \
    template <class combiner, class or_type> \
    typename pythonic::assignable<funcname##_globals<N>::global_type<combiner, or_type> >::type \
    funcname##_global_type(int) {}\
    } /*End namespace */

#define pythran_export_solo(module, funcname, ...) \
    pythran_export_start(module, funcname, ##__VA_ARGS__) \
    template <class combiner, class or_type> \
    typename pythonic::assignable<funcname##_globals<__COUNTER__-1>::global_type<combiner, or_type> >::type \
    funcname##_global_type(int) {}\
    } /*End namespace */

#endif //PYTHONIC_PYTHON_EXPORT_HPP
